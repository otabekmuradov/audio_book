// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'audiobook_info_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AudioBookInfoEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAudioBookInfo,
    required TResult Function() shuffleAudio,
    required TResult Function() repeatAudio,
    required TResult Function() addQueueItems,
    required TResult Function(bool isPlaying) controlAudio,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAudioBookInfo,
    TResult? Function()? shuffleAudio,
    TResult? Function()? repeatAudio,
    TResult? Function()? addQueueItems,
    TResult? Function(bool isPlaying)? controlAudio,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAudioBookInfo,
    TResult Function()? shuffleAudio,
    TResult Function()? repeatAudio,
    TResult Function()? addQueueItems,
    TResult Function(bool isPlaying)? controlAudio,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAudioBookInfo value) getAudioBookInfo,
    required TResult Function(_ShuffleAudio value) shuffleAudio,
    required TResult Function(_RepeatAudio value) repeatAudio,
    required TResult Function(_AddQueueItems value) addQueueItems,
    required TResult Function(_ControlAudio value) controlAudio,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetAudioBookInfo value)? getAudioBookInfo,
    TResult? Function(_ShuffleAudio value)? shuffleAudio,
    TResult? Function(_RepeatAudio value)? repeatAudio,
    TResult? Function(_AddQueueItems value)? addQueueItems,
    TResult? Function(_ControlAudio value)? controlAudio,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAudioBookInfo value)? getAudioBookInfo,
    TResult Function(_ShuffleAudio value)? shuffleAudio,
    TResult Function(_RepeatAudio value)? repeatAudio,
    TResult Function(_AddQueueItems value)? addQueueItems,
    TResult Function(_ControlAudio value)? controlAudio,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AudioBookInfoEventCopyWith<$Res> {
  factory $AudioBookInfoEventCopyWith(
          AudioBookInfoEvent value, $Res Function(AudioBookInfoEvent) then) =
      _$AudioBookInfoEventCopyWithImpl<$Res, AudioBookInfoEvent>;
}

/// @nodoc
class _$AudioBookInfoEventCopyWithImpl<$Res, $Val extends AudioBookInfoEvent>
    implements $AudioBookInfoEventCopyWith<$Res> {
  _$AudioBookInfoEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$GetAudioBookInfoImplCopyWith<$Res> {
  factory _$$GetAudioBookInfoImplCopyWith(_$GetAudioBookInfoImpl value,
          $Res Function(_$GetAudioBookInfoImpl) then) =
      __$$GetAudioBookInfoImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetAudioBookInfoImplCopyWithImpl<$Res>
    extends _$AudioBookInfoEventCopyWithImpl<$Res, _$GetAudioBookInfoImpl>
    implements _$$GetAudioBookInfoImplCopyWith<$Res> {
  __$$GetAudioBookInfoImplCopyWithImpl(_$GetAudioBookInfoImpl _value,
      $Res Function(_$GetAudioBookInfoImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetAudioBookInfoImpl implements _GetAudioBookInfo {
  const _$GetAudioBookInfoImpl();

  @override
  String toString() {
    return 'AudioBookInfoEvent.getAudioBookInfo()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetAudioBookInfoImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAudioBookInfo,
    required TResult Function() shuffleAudio,
    required TResult Function() repeatAudio,
    required TResult Function() addQueueItems,
    required TResult Function(bool isPlaying) controlAudio,
  }) {
    return getAudioBookInfo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAudioBookInfo,
    TResult? Function()? shuffleAudio,
    TResult? Function()? repeatAudio,
    TResult? Function()? addQueueItems,
    TResult? Function(bool isPlaying)? controlAudio,
  }) {
    return getAudioBookInfo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAudioBookInfo,
    TResult Function()? shuffleAudio,
    TResult Function()? repeatAudio,
    TResult Function()? addQueueItems,
    TResult Function(bool isPlaying)? controlAudio,
    required TResult orElse(),
  }) {
    if (getAudioBookInfo != null) {
      return getAudioBookInfo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAudioBookInfo value) getAudioBookInfo,
    required TResult Function(_ShuffleAudio value) shuffleAudio,
    required TResult Function(_RepeatAudio value) repeatAudio,
    required TResult Function(_AddQueueItems value) addQueueItems,
    required TResult Function(_ControlAudio value) controlAudio,
  }) {
    return getAudioBookInfo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetAudioBookInfo value)? getAudioBookInfo,
    TResult? Function(_ShuffleAudio value)? shuffleAudio,
    TResult? Function(_RepeatAudio value)? repeatAudio,
    TResult? Function(_AddQueueItems value)? addQueueItems,
    TResult? Function(_ControlAudio value)? controlAudio,
  }) {
    return getAudioBookInfo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAudioBookInfo value)? getAudioBookInfo,
    TResult Function(_ShuffleAudio value)? shuffleAudio,
    TResult Function(_RepeatAudio value)? repeatAudio,
    TResult Function(_AddQueueItems value)? addQueueItems,
    TResult Function(_ControlAudio value)? controlAudio,
    required TResult orElse(),
  }) {
    if (getAudioBookInfo != null) {
      return getAudioBookInfo(this);
    }
    return orElse();
  }
}

abstract class _GetAudioBookInfo implements AudioBookInfoEvent {
  const factory _GetAudioBookInfo() = _$GetAudioBookInfoImpl;
}

/// @nodoc
abstract class _$$ShuffleAudioImplCopyWith<$Res> {
  factory _$$ShuffleAudioImplCopyWith(
          _$ShuffleAudioImpl value, $Res Function(_$ShuffleAudioImpl) then) =
      __$$ShuffleAudioImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ShuffleAudioImplCopyWithImpl<$Res>
    extends _$AudioBookInfoEventCopyWithImpl<$Res, _$ShuffleAudioImpl>
    implements _$$ShuffleAudioImplCopyWith<$Res> {
  __$$ShuffleAudioImplCopyWithImpl(
      _$ShuffleAudioImpl _value, $Res Function(_$ShuffleAudioImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ShuffleAudioImpl implements _ShuffleAudio {
  const _$ShuffleAudioImpl();

  @override
  String toString() {
    return 'AudioBookInfoEvent.shuffleAudio()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ShuffleAudioImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAudioBookInfo,
    required TResult Function() shuffleAudio,
    required TResult Function() repeatAudio,
    required TResult Function() addQueueItems,
    required TResult Function(bool isPlaying) controlAudio,
  }) {
    return shuffleAudio();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAudioBookInfo,
    TResult? Function()? shuffleAudio,
    TResult? Function()? repeatAudio,
    TResult? Function()? addQueueItems,
    TResult? Function(bool isPlaying)? controlAudio,
  }) {
    return shuffleAudio?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAudioBookInfo,
    TResult Function()? shuffleAudio,
    TResult Function()? repeatAudio,
    TResult Function()? addQueueItems,
    TResult Function(bool isPlaying)? controlAudio,
    required TResult orElse(),
  }) {
    if (shuffleAudio != null) {
      return shuffleAudio();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAudioBookInfo value) getAudioBookInfo,
    required TResult Function(_ShuffleAudio value) shuffleAudio,
    required TResult Function(_RepeatAudio value) repeatAudio,
    required TResult Function(_AddQueueItems value) addQueueItems,
    required TResult Function(_ControlAudio value) controlAudio,
  }) {
    return shuffleAudio(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetAudioBookInfo value)? getAudioBookInfo,
    TResult? Function(_ShuffleAudio value)? shuffleAudio,
    TResult? Function(_RepeatAudio value)? repeatAudio,
    TResult? Function(_AddQueueItems value)? addQueueItems,
    TResult? Function(_ControlAudio value)? controlAudio,
  }) {
    return shuffleAudio?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAudioBookInfo value)? getAudioBookInfo,
    TResult Function(_ShuffleAudio value)? shuffleAudio,
    TResult Function(_RepeatAudio value)? repeatAudio,
    TResult Function(_AddQueueItems value)? addQueueItems,
    TResult Function(_ControlAudio value)? controlAudio,
    required TResult orElse(),
  }) {
    if (shuffleAudio != null) {
      return shuffleAudio(this);
    }
    return orElse();
  }
}

abstract class _ShuffleAudio implements AudioBookInfoEvent {
  const factory _ShuffleAudio() = _$ShuffleAudioImpl;
}

/// @nodoc
abstract class _$$RepeatAudioImplCopyWith<$Res> {
  factory _$$RepeatAudioImplCopyWith(
          _$RepeatAudioImpl value, $Res Function(_$RepeatAudioImpl) then) =
      __$$RepeatAudioImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RepeatAudioImplCopyWithImpl<$Res>
    extends _$AudioBookInfoEventCopyWithImpl<$Res, _$RepeatAudioImpl>
    implements _$$RepeatAudioImplCopyWith<$Res> {
  __$$RepeatAudioImplCopyWithImpl(
      _$RepeatAudioImpl _value, $Res Function(_$RepeatAudioImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RepeatAudioImpl implements _RepeatAudio {
  const _$RepeatAudioImpl();

  @override
  String toString() {
    return 'AudioBookInfoEvent.repeatAudio()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RepeatAudioImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAudioBookInfo,
    required TResult Function() shuffleAudio,
    required TResult Function() repeatAudio,
    required TResult Function() addQueueItems,
    required TResult Function(bool isPlaying) controlAudio,
  }) {
    return repeatAudio();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAudioBookInfo,
    TResult? Function()? shuffleAudio,
    TResult? Function()? repeatAudio,
    TResult? Function()? addQueueItems,
    TResult? Function(bool isPlaying)? controlAudio,
  }) {
    return repeatAudio?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAudioBookInfo,
    TResult Function()? shuffleAudio,
    TResult Function()? repeatAudio,
    TResult Function()? addQueueItems,
    TResult Function(bool isPlaying)? controlAudio,
    required TResult orElse(),
  }) {
    if (repeatAudio != null) {
      return repeatAudio();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAudioBookInfo value) getAudioBookInfo,
    required TResult Function(_ShuffleAudio value) shuffleAudio,
    required TResult Function(_RepeatAudio value) repeatAudio,
    required TResult Function(_AddQueueItems value) addQueueItems,
    required TResult Function(_ControlAudio value) controlAudio,
  }) {
    return repeatAudio(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetAudioBookInfo value)? getAudioBookInfo,
    TResult? Function(_ShuffleAudio value)? shuffleAudio,
    TResult? Function(_RepeatAudio value)? repeatAudio,
    TResult? Function(_AddQueueItems value)? addQueueItems,
    TResult? Function(_ControlAudio value)? controlAudio,
  }) {
    return repeatAudio?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAudioBookInfo value)? getAudioBookInfo,
    TResult Function(_ShuffleAudio value)? shuffleAudio,
    TResult Function(_RepeatAudio value)? repeatAudio,
    TResult Function(_AddQueueItems value)? addQueueItems,
    TResult Function(_ControlAudio value)? controlAudio,
    required TResult orElse(),
  }) {
    if (repeatAudio != null) {
      return repeatAudio(this);
    }
    return orElse();
  }
}

abstract class _RepeatAudio implements AudioBookInfoEvent {
  const factory _RepeatAudio() = _$RepeatAudioImpl;
}

/// @nodoc
abstract class _$$AddQueueItemsImplCopyWith<$Res> {
  factory _$$AddQueueItemsImplCopyWith(
          _$AddQueueItemsImpl value, $Res Function(_$AddQueueItemsImpl) then) =
      __$$AddQueueItemsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddQueueItemsImplCopyWithImpl<$Res>
    extends _$AudioBookInfoEventCopyWithImpl<$Res, _$AddQueueItemsImpl>
    implements _$$AddQueueItemsImplCopyWith<$Res> {
  __$$AddQueueItemsImplCopyWithImpl(
      _$AddQueueItemsImpl _value, $Res Function(_$AddQueueItemsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddQueueItemsImpl implements _AddQueueItems {
  const _$AddQueueItemsImpl();

  @override
  String toString() {
    return 'AudioBookInfoEvent.addQueueItems()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AddQueueItemsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAudioBookInfo,
    required TResult Function() shuffleAudio,
    required TResult Function() repeatAudio,
    required TResult Function() addQueueItems,
    required TResult Function(bool isPlaying) controlAudio,
  }) {
    return addQueueItems();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAudioBookInfo,
    TResult? Function()? shuffleAudio,
    TResult? Function()? repeatAudio,
    TResult? Function()? addQueueItems,
    TResult? Function(bool isPlaying)? controlAudio,
  }) {
    return addQueueItems?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAudioBookInfo,
    TResult Function()? shuffleAudio,
    TResult Function()? repeatAudio,
    TResult Function()? addQueueItems,
    TResult Function(bool isPlaying)? controlAudio,
    required TResult orElse(),
  }) {
    if (addQueueItems != null) {
      return addQueueItems();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAudioBookInfo value) getAudioBookInfo,
    required TResult Function(_ShuffleAudio value) shuffleAudio,
    required TResult Function(_RepeatAudio value) repeatAudio,
    required TResult Function(_AddQueueItems value) addQueueItems,
    required TResult Function(_ControlAudio value) controlAudio,
  }) {
    return addQueueItems(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetAudioBookInfo value)? getAudioBookInfo,
    TResult? Function(_ShuffleAudio value)? shuffleAudio,
    TResult? Function(_RepeatAudio value)? repeatAudio,
    TResult? Function(_AddQueueItems value)? addQueueItems,
    TResult? Function(_ControlAudio value)? controlAudio,
  }) {
    return addQueueItems?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAudioBookInfo value)? getAudioBookInfo,
    TResult Function(_ShuffleAudio value)? shuffleAudio,
    TResult Function(_RepeatAudio value)? repeatAudio,
    TResult Function(_AddQueueItems value)? addQueueItems,
    TResult Function(_ControlAudio value)? controlAudio,
    required TResult orElse(),
  }) {
    if (addQueueItems != null) {
      return addQueueItems(this);
    }
    return orElse();
  }
}

abstract class _AddQueueItems implements AudioBookInfoEvent {
  const factory _AddQueueItems() = _$AddQueueItemsImpl;
}

/// @nodoc
abstract class _$$ControlAudioImplCopyWith<$Res> {
  factory _$$ControlAudioImplCopyWith(
          _$ControlAudioImpl value, $Res Function(_$ControlAudioImpl) then) =
      __$$ControlAudioImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isPlaying});
}

/// @nodoc
class __$$ControlAudioImplCopyWithImpl<$Res>
    extends _$AudioBookInfoEventCopyWithImpl<$Res, _$ControlAudioImpl>
    implements _$$ControlAudioImplCopyWith<$Res> {
  __$$ControlAudioImplCopyWithImpl(
      _$ControlAudioImpl _value, $Res Function(_$ControlAudioImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isPlaying = null,
  }) {
    return _then(_$ControlAudioImpl(
      isPlaying: null == isPlaying
          ? _value.isPlaying
          : isPlaying // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ControlAudioImpl implements _ControlAudio {
  const _$ControlAudioImpl({required this.isPlaying});

  @override
  final bool isPlaying;

  @override
  String toString() {
    return 'AudioBookInfoEvent.controlAudio(isPlaying: $isPlaying)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ControlAudioImpl &&
            (identical(other.isPlaying, isPlaying) ||
                other.isPlaying == isPlaying));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isPlaying);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ControlAudioImplCopyWith<_$ControlAudioImpl> get copyWith =>
      __$$ControlAudioImplCopyWithImpl<_$ControlAudioImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAudioBookInfo,
    required TResult Function() shuffleAudio,
    required TResult Function() repeatAudio,
    required TResult Function() addQueueItems,
    required TResult Function(bool isPlaying) controlAudio,
  }) {
    return controlAudio(isPlaying);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAudioBookInfo,
    TResult? Function()? shuffleAudio,
    TResult? Function()? repeatAudio,
    TResult? Function()? addQueueItems,
    TResult? Function(bool isPlaying)? controlAudio,
  }) {
    return controlAudio?.call(isPlaying);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAudioBookInfo,
    TResult Function()? shuffleAudio,
    TResult Function()? repeatAudio,
    TResult Function()? addQueueItems,
    TResult Function(bool isPlaying)? controlAudio,
    required TResult orElse(),
  }) {
    if (controlAudio != null) {
      return controlAudio(isPlaying);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAudioBookInfo value) getAudioBookInfo,
    required TResult Function(_ShuffleAudio value) shuffleAudio,
    required TResult Function(_RepeatAudio value) repeatAudio,
    required TResult Function(_AddQueueItems value) addQueueItems,
    required TResult Function(_ControlAudio value) controlAudio,
  }) {
    return controlAudio(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetAudioBookInfo value)? getAudioBookInfo,
    TResult? Function(_ShuffleAudio value)? shuffleAudio,
    TResult? Function(_RepeatAudio value)? repeatAudio,
    TResult? Function(_AddQueueItems value)? addQueueItems,
    TResult? Function(_ControlAudio value)? controlAudio,
  }) {
    return controlAudio?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAudioBookInfo value)? getAudioBookInfo,
    TResult Function(_ShuffleAudio value)? shuffleAudio,
    TResult Function(_RepeatAudio value)? repeatAudio,
    TResult Function(_AddQueueItems value)? addQueueItems,
    TResult Function(_ControlAudio value)? controlAudio,
    required TResult orElse(),
  }) {
    if (controlAudio != null) {
      return controlAudio(this);
    }
    return orElse();
  }
}

abstract class _ControlAudio implements AudioBookInfoEvent {
  const factory _ControlAudio({required final bool isPlaying}) =
      _$ControlAudioImpl;

  bool get isPlaying;
  @JsonKey(ignore: true)
  _$$ControlAudioImplCopyWith<_$ControlAudioImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AudioBookInfoState {
  Statuses get status => throw _privateConstructorUsedError;
  Failure? get error => throw _privateConstructorUsedError;
  List<AudioBookInfo> get audioBookInfo => throw _privateConstructorUsedError;
  bool get isPlaying => throw _privateConstructorUsedError;
  RepeatState get repeatState => throw _privateConstructorUsedError;
  bool get isShuffleEnabled => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AudioBookInfoStateCopyWith<AudioBookInfoState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AudioBookInfoStateCopyWith<$Res> {
  factory $AudioBookInfoStateCopyWith(
          AudioBookInfoState value, $Res Function(AudioBookInfoState) then) =
      _$AudioBookInfoStateCopyWithImpl<$Res, AudioBookInfoState>;
  @useResult
  $Res call(
      {Statuses status,
      Failure? error,
      List<AudioBookInfo> audioBookInfo,
      bool isPlaying,
      RepeatState repeatState,
      bool isShuffleEnabled});
}

/// @nodoc
class _$AudioBookInfoStateCopyWithImpl<$Res, $Val extends AudioBookInfoState>
    implements $AudioBookInfoStateCopyWith<$Res> {
  _$AudioBookInfoStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? error = freezed,
    Object? audioBookInfo = null,
    Object? isPlaying = null,
    Object? repeatState = null,
    Object? isShuffleEnabled = null,
  }) {
    return _then(_value.copyWith(
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Statuses,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as Failure?,
      audioBookInfo: null == audioBookInfo
          ? _value.audioBookInfo
          : audioBookInfo // ignore: cast_nullable_to_non_nullable
              as List<AudioBookInfo>,
      isPlaying: null == isPlaying
          ? _value.isPlaying
          : isPlaying // ignore: cast_nullable_to_non_nullable
              as bool,
      repeatState: null == repeatState
          ? _value.repeatState
          : repeatState // ignore: cast_nullable_to_non_nullable
              as RepeatState,
      isShuffleEnabled: null == isShuffleEnabled
          ? _value.isShuffleEnabled
          : isShuffleEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AudioBookInfoStateImplCopyWith<$Res>
    implements $AudioBookInfoStateCopyWith<$Res> {
  factory _$$AudioBookInfoStateImplCopyWith(_$AudioBookInfoStateImpl value,
          $Res Function(_$AudioBookInfoStateImpl) then) =
      __$$AudioBookInfoStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Statuses status,
      Failure? error,
      List<AudioBookInfo> audioBookInfo,
      bool isPlaying,
      RepeatState repeatState,
      bool isShuffleEnabled});
}

/// @nodoc
class __$$AudioBookInfoStateImplCopyWithImpl<$Res>
    extends _$AudioBookInfoStateCopyWithImpl<$Res, _$AudioBookInfoStateImpl>
    implements _$$AudioBookInfoStateImplCopyWith<$Res> {
  __$$AudioBookInfoStateImplCopyWithImpl(_$AudioBookInfoStateImpl _value,
      $Res Function(_$AudioBookInfoStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? error = freezed,
    Object? audioBookInfo = null,
    Object? isPlaying = null,
    Object? repeatState = null,
    Object? isShuffleEnabled = null,
  }) {
    return _then(_$AudioBookInfoStateImpl(
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Statuses,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as Failure?,
      audioBookInfo: null == audioBookInfo
          ? _value._audioBookInfo
          : audioBookInfo // ignore: cast_nullable_to_non_nullable
              as List<AudioBookInfo>,
      isPlaying: null == isPlaying
          ? _value.isPlaying
          : isPlaying // ignore: cast_nullable_to_non_nullable
              as bool,
      repeatState: null == repeatState
          ? _value.repeatState
          : repeatState // ignore: cast_nullable_to_non_nullable
              as RepeatState,
      isShuffleEnabled: null == isShuffleEnabled
          ? _value.isShuffleEnabled
          : isShuffleEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$AudioBookInfoStateImpl implements _AudioBookInfoState {
  const _$AudioBookInfoStateImpl(
      {this.status = Statuses.initial,
      this.error,
      final List<AudioBookInfo> audioBookInfo = const [],
      this.isPlaying = false,
      this.repeatState = RepeatState.off,
      this.isShuffleEnabled = false})
      : _audioBookInfo = audioBookInfo;

  @override
  @JsonKey()
  final Statuses status;
  @override
  final Failure? error;
  final List<AudioBookInfo> _audioBookInfo;
  @override
  @JsonKey()
  List<AudioBookInfo> get audioBookInfo {
    if (_audioBookInfo is EqualUnmodifiableListView) return _audioBookInfo;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_audioBookInfo);
  }

  @override
  @JsonKey()
  final bool isPlaying;
  @override
  @JsonKey()
  final RepeatState repeatState;
  @override
  @JsonKey()
  final bool isShuffleEnabled;

  @override
  String toString() {
    return 'AudioBookInfoState(status: $status, error: $error, audioBookInfo: $audioBookInfo, isPlaying: $isPlaying, repeatState: $repeatState, isShuffleEnabled: $isShuffleEnabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AudioBookInfoStateImpl &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.error, error) || other.error == error) &&
            const DeepCollectionEquality()
                .equals(other._audioBookInfo, _audioBookInfo) &&
            (identical(other.isPlaying, isPlaying) ||
                other.isPlaying == isPlaying) &&
            (identical(other.repeatState, repeatState) ||
                other.repeatState == repeatState) &&
            (identical(other.isShuffleEnabled, isShuffleEnabled) ||
                other.isShuffleEnabled == isShuffleEnabled));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      status,
      error,
      const DeepCollectionEquality().hash(_audioBookInfo),
      isPlaying,
      repeatState,
      isShuffleEnabled);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AudioBookInfoStateImplCopyWith<_$AudioBookInfoStateImpl> get copyWith =>
      __$$AudioBookInfoStateImplCopyWithImpl<_$AudioBookInfoStateImpl>(
          this, _$identity);
}

abstract class _AudioBookInfoState implements AudioBookInfoState {
  const factory _AudioBookInfoState(
      {final Statuses status,
      final Failure? error,
      final List<AudioBookInfo> audioBookInfo,
      final bool isPlaying,
      final RepeatState repeatState,
      final bool isShuffleEnabled}) = _$AudioBookInfoStateImpl;

  @override
  Statuses get status;
  @override
  Failure? get error;
  @override
  List<AudioBookInfo> get audioBookInfo;
  @override
  bool get isPlaying;
  @override
  RepeatState get repeatState;
  @override
  bool get isShuffleEnabled;
  @override
  @JsonKey(ignore: true)
  _$$AudioBookInfoStateImplCopyWith<_$AudioBookInfoStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
